<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Risto Stevcev's Blog - Clojure Specs</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Risto Stevcev's Blog</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Clojure Specs</h1>

            <div class="info">
    Posted on October  1, 2016
    
</div>

<p>The Clojure community recently introduced a powerful new language feature called specs, which is available for both Clojure and ClojureScript. It’s intended to replace the need for core.typed, and introduces some powerful features into the language to ensure type safety. Specs provide a flexible way to write type signatures.</p>
<ul>
<li><p><i class="fa-li fa fa-code"></i><strong>Instrumentation</strong><br />
With <code>instrument</code>, you can have your specs type check at runtime. So if you try to call a function that takes a single parameter that’s a <code>string?</code>, and you give it a number, this will throw an error instead of attempting to execute the function body.</p></li>
<li><p><i class="fa-li fa fa-code"></i><strong>Generative tests for free</strong><br />
Specs also give you generative tests for free. This is very convenient because specs are predicate based, and so this saves you from writing the extra boilerplate for generative tests.</p></li>
<li><p><i class="fa-li fa fa-code"></i><strong>Simulating compile-time type checking</strong><br />
You can simulate compile-time type checking by adding generative tests for each of the specs and having them run with figwheel. These tests will run immediately. It’s like compile-time type checking in some ways because the tests will fail if the types don’t match without having to run your application’s code.</p></li>
<li><p><i class="fa-li fa fa-code"></i><strong>Simulating refinement and dependent types</strong><br />
Since specs are based on predicate expressions, they are a lot like refinement types such as Liquid Haskell. And since the types are values, you get something like dependent types. It should be possible to write Idris-like proofs to some capacity.</p></li>
</ul>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
            <a href="atom.xml"><i class="fa fa-rss-square"></i></a>
        </div>
    </body>
</html>
